# whisperjav/modules/subtitle_sanitizer.py

import pysrt
import shutil
from pathlib import Path
from typing import List, Dict, Tuple, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict

from whisperjav.utils.logger import logger
from whisperjav.config.sanitization_config import SanitizationConfig
from whisperjav.modules.hallucination_remover import HallucinationRemover
from whisperjav.modules.repetition_cleaner import RepetitionCleaner
from whisperjav.modules.cross_subtitle_processor import CrossSubtitleProcessor
from whisperjav.modules.timing_adjuster import TimingAdjuster

@dataclass
class SanitizationResult:
    """Result of sanitization process"""
    sanitized_path: Path
    original_backup_path: Optional[Path]
    artifacts_path: Optional[Path]
    statistics: Dict[str, Any]
    processing_time: float
    
@dataclass
class ArtifactEntry:
    """Represents a removed or modified subtitle entry"""
    index: int
    start_time: str
    end_time: str
    original_text: str
    modified_text: Optional[str]  # None if completely removed
    reason: str
    category: str
    confidence: float
    pattern: Optional[str]
    step: str
    additional_info: Dict[str, Any]

@dataclass
class Phase1Stats:
    """Statistics for Phase 1 processing"""
    original_count: int = 0
    exact_hall_pass1_removed: int = 0
    repetition_cleaned: int = 0
    exact_hall_pass2_removed: int = 0
    empty_purged: int = 0
    final_count: int = 0
    hallucination_phrases_loaded: Dict[str, int] = None

class SubtitleSanitizer:
    """Comprehensive subtitle sanitization system with improved Phase 1"""
    
    def __init__(self, config: Optional[SanitizationConfig] = None,
                 config_file: Optional[Path] = None,
                 testing_profile: Optional[str] = None):
        
        # Initialize configuration
        if config:
            self.config = config
        elif config_file:
            self.config = SanitizationConfig.from_file(config_file)
        elif testing_profile:
            from whisperjav.config.sanitization_config import get_testing_profile
            self.config = get_testing_profile(testing_profile)
        else:
            self.config = SanitizationConfig()
            
        # Apply environment overrides
        if not config:  # Only apply env overrides if not explicitly configured
            self.config = SanitizationConfig.from_env()
            
        # Get effective constants
        self.constants = self.config.get_effective_constants()
        
        # Initialize processors
        self._init_processors()
        
        # Track all modifications
        self.artifact_entries: List[ArtifactEntry] = []
        
        # Phase 1 statistics
        self.phase1_stats = Phase1Stats()
        
        logger.info(f"SubtitleSanitizer initialized with sensitivity: {self.config.sensitivity_mode}")
        
    def _init_processors(self):
        """Initialize all sub-processors"""
        # Hallucination remover
        if self.config.enable_exact_matching or self.config.enable_regex_matching or self.config.enable_fuzzy_matching:
            self.hallucination_remover = HallucinationRemover(
                self.constants['hallucination'],
                self.config.primary_language,
                self.config.user_blacklist_patterns
            )
        else:
            self.hallucination_remover = None
            
        # Repetition cleaner
        if self.config.enable_repetition_cleaning:
            self.repetition_cleaner = RepetitionCleaner(self.constants['repetition'])
        else:
            self.repetition_cleaner = None
            
        # Cross-subtitle processor
        if self.config.enable_cross_subtitle:
            self.cross_subtitle_processor = CrossSubtitleProcessor(
                self.constants['cross_subtitle'],
                self.config.primary_language
            )
        else:
            self.cross_subtitle_processor = None
            
        # IMPROVED: Use content-aware timing adjuster
        self.timing_adjuster = TimingAdjuster(
            self.constants['timing'],
            self.constants['cross_subtitle'],
            self.config.primary_language
        )
        
    def process(self, input_srt_path: Path) -> SanitizationResult:
        """Process SRT file using improved pipeline with content-aware timing"""
        start_time = datetime.now()
        input_srt_path = Path(input_srt_path)
        
        logger.info(f"Starting improved sanitization of: {input_srt_path}")
        
        # Validate input
        if not input_srt_path.exists():
            raise FileNotFoundError(f"Input SRT file not found: {input_srt_path}")
            
        # Setup output paths
        paths = self._setup_output_paths(input_srt_path)
        
        # Save original if requested
        if self.config.save_original:
            shutil.copy2(input_srt_path, paths['original_backup'])
            logger.info(f"Saved original backup to: {paths['original_backup']}")
            
        # Load subtitles
        try:
            original_subtitles = list(pysrt.open(str(input_srt_path), encoding='utf-8'))
            logger.info(f"Loaded {len(original_subtitles)} subtitles")
        except Exception as e:
            logger.error(f"Failed to load SRT file: {e}")
            raise
            
        # Clear previous artifacts and stats
        self.artifact_entries.clear()
        self.phase1_stats = Phase1Stats()
        self.phase1_stats.original_count = len(original_subtitles)
        
        # Log hallucination database info
        self._log_hallucination_database_info()
        
        # IMPROVED PIPELINE: Content changes first, timing adjustments last
        logger.info("=== STARTING IMPROVED SANITIZATION PIPELINE ===")
        
        # PHASE 1: Content Cleaning (no timing changes)
        content_cleaned_subtitles = self._process_phase1_conservative(original_subtitles)
        
        # PHASE 2: Content-Aware Timing Adjustment (NEW - happens AFTER content changes)
        logger.info("=== PHASE 2: Content-Aware Timing Adjustment ===")
        final_subtitles = self._process_content_aware_timing(original_subtitles, content_cleaned_subtitles)
        
        # Log results
        self._log_phase1_results()
        
        # Save outputs
        output_path = paths['original'] if not self.config.preserve_original_file else paths['sanitized']
        self._save_srt(final_subtitles, output_path)
        
        if self.config.save_artifacts and self.artifact_entries:
            self._save_artifacts_srt(paths['artifacts'])
            
        # Calculate statistics
        processing_time = (datetime.now() - start_time).total_seconds()
        statistics = self._calculate_statistics(len(original_subtitles), len(final_subtitles))
        
        # Create result
        result = SanitizationResult(
            sanitized_path=output_path,
            original_backup_path=paths['original_backup'] if self.config.save_original else None,
            artifacts_path=paths['artifacts'] if self.config.save_artifacts and self.artifact_entries else None,
            statistics=statistics,
            processing_time=processing_time
        )
        
        logger.info(f"Improved sanitization complete in {processing_time:.2f}s. "
                   f"Subtitles: {len(original_subtitles)} → {len(final_subtitles)}")
        
        return result

    def _process_content_aware_timing(self, 
                                    original_subtitles: List[pysrt.SubRipItem],
                                    content_cleaned_subtitles: List[pysrt.SubRipItem]) -> List[pysrt.SubRipItem]:
        """
        PHASE 2: Apply content-aware timing adjustments AFTER all content changes
        Uses user's strategy: only adjust if content changed, keep end fixed, adjust start
        """
        logger.info("Phase 2.1: Applying content-aware timing adjustments")
        
        # Apply improved timing strategy
        timing_adjusted_subs, timing_mods = self.timing_adjuster.adjust_timings_content_aware(
            original_subtitles, content_cleaned_subtitles
        )
        
        # Record timing modifications in artifacts
        for mod in timing_mods:
            self._record_timing_modification(mod)
            
        logger.info(f"Content-aware timing complete: {len(timing_mods)} adjustments made")
        
        self.phase1_stats.final_count = len(timing_adjusted_subs)
        return timing_adjusted_subs

    def _record_timing_modification(self, modification: Dict):
        """Record timing adjustment in artifacts"""
        if self.config.artifact_detail_level == "minimal":
            return
            
        entry = ArtifactEntry(
            index=modification.get('subtitle_index', 0),
            start_time=str(modification.get('original_start', '')),
            end_time=str(modification.get('end_timestamp', '')),
            original_text=modification.get('original_text', 'N/A'),
            modified_text=modification.get('original_text', 'N/A'),  # Text unchanged in timing adjustments
            reason=modification.get('reason', 'timing_adjustment'),
            category="content_aware_timing",
            confidence=1.0,
            pattern=None,
            step="content_aware_timing_adjustment",
            additional_info=modification if self.config.artifact_detail_level == "full" else {}
        )
        self.artifact_entries.append(entry)

    def _log_hallucination_database_info(self):
        """Log information about loaded hallucination databases"""
        if not self.hallucination_remover:
            logger.info("Hallucination removal disabled")
            return
            
        # Get hallucination database info
        exact_lists = getattr(self.hallucination_remover, '_exact_lists', {})
        regex_patterns = getattr(self.hallucination_remover, '_regex_patterns', [])
        blacklist_phrases = getattr(self.hallucination_remover, '_blacklist_phrases', [])
        
        # Log database sizes
        logger.info("=== HALLUCINATION DATABASE INFO ===")
        
        if exact_lists:
            total_exact = sum(len(phrases) for phrases in exact_lists.values() if isinstance(phrases, (list, set)))
            logger.info(f"Exact match lists loaded for {len(exact_lists)} languages, total phrases: {total_exact}")
            for lang, phrases in exact_lists.items():
                count = len(phrases) if isinstance(phrases, (list, set)) else 0
                logger.info(f"  - {lang}: {count} phrases")
                
            # Store for stats
            self.phase1_stats.hallucination_phrases_loaded = {
                lang: len(phrases) if isinstance(phrases, (list, set)) else 0 
                for lang, phrases in exact_lists.items()
            }
        else:
            logger.warning("No exact match hallucination lists loaded")
            
        if regex_patterns:
            logger.info(f"Regex patterns loaded: {len(regex_patterns)}")
        else:
            logger.warning("No regex patterns loaded")
            
        if blacklist_phrases:
            logger.info(f"Fuzzy match blacklist phrases: {len(blacklist_phrases)}")
        else:
            logger.info("No fuzzy match blacklist phrases loaded")
            
        logger.info("=====================================")

    def _process_phase1_conservative(self, subtitles: List[pysrt.SubRipItem]) -> List[pysrt.SubRipItem]:
        """
        NEW PHASE 1: Conservative Content Cleaning
        1. Empty text validation
        2. Exact hallucination matching (first pass)
        3. Extreme repetition pre-cleaning (only obvious cases)
        4. Exact hallucination matching (second pass)
        5. Purge empty subs
        6. Renumber SRT
        """
        logger.info("=== STARTING PHASE 1: Conservative Content Cleaning ===")
        
        current_subtitles = subtitles.copy()
        
        # Step 1: Empty text validation
        logger.info("Phase 1.1: Empty text validation")
        current_subtitles = self._phase1_remove_empty(current_subtitles)
        
        # Step 2: Exact hallucination matching (first pass)
        logger.info("Phase 1.2: Exact hallucination matching (first pass)")
        current_subtitles = self._phase1_exact_hallucination_pass(current_subtitles, pass_number=1)
        
        # Step 3: Extreme repetition pre-cleaning (only obvious cases)
        logger.info("Phase 1.3: Extreme repetition pre-cleaning")
        current_subtitles = self._phase1_extreme_repetition_cleaning(current_subtitles)
        
        # Step 4: Exact hallucination matching (second pass)
        logger.info("Phase 1.4: Exact hallucination matching (second pass)")
        current_subtitles = self._phase1_exact_hallucination_pass(current_subtitles, pass_number=2)
        
        # Step 5: Purge empty subs that might have been created
        logger.info("Phase 1.5: Purging empty subtitles")
        current_subtitles = self._phase1_purge_empty(current_subtitles)
        
        # Step 6: Renumber SRT
        logger.info("Phase 1.6: Renumbering subtitles")
        current_subtitles = self._phase1_renumber(current_subtitles)
        
        self.phase1_stats.final_count = len(current_subtitles)
        
        logger.info(f"=== PHASE 1 COMPLETE: {self.phase1_stats.original_count} → {self.phase1_stats.final_count} subtitles ===")
        
        return current_subtitles

    def _phase1_remove_empty(self, subtitles: List[pysrt.SubRipItem]) -> List[pysrt.SubRipItem]:
        """Remove subtitles with empty or whitespace-only text"""
        filtered = []
        removed_count = 0
        
        for i, sub in enumerate(subtitles):
            if not sub.text or not sub.text.strip():
                self._record_removal(sub, i, "empty_text_initial", "validation")
                removed_count += 1
            else:
                filtered.append(sub)
                
        logger.info(f"  Removed {removed_count} initially empty subtitles")
        return filtered

    def _phase1_exact_hallucination_pass(self, subtitles: List[pysrt.SubRipItem], pass_number: int) -> List[pysrt.SubRipItem]:
        """Apply only exact hallucination matching"""
        if not self.hallucination_remover or not self.config.enable_exact_matching:
            logger.info(f"  Exact hallucination matching pass {pass_number} skipped (disabled)")
            return subtitles
            
        filtered = []
        removed_count = 0
        modified_count = 0
        
        for i, sub in enumerate(subtitles):
            # Apply only exact matching
            cleaned_text, mods = self.hallucination_remover._apply_exact_matching(
                sub.text, self.config.primary_language
            )
            
            if not cleaned_text:
                # Completely removed
                self._record_removal(sub, i, f"exact_hallucination_pass{pass_number}", "hallucination")
                removed_count += 1
            elif cleaned_text != sub.text:
                # Modified
                modified_sub = pysrt.SubRipItem(
                    index=sub.index,
                    start=sub.start,
                    end=sub.end,
                    text=cleaned_text
                )
                self._record_modification(sub, modified_sub, i, mods, f"exact_hallucination_pass{pass_number}")
                filtered.append(modified_sub)
                modified_count += 1
            else:
                # Unchanged
                filtered.append(sub)
                
        # Update stats
        if pass_number == 1:
            self.phase1_stats.exact_hall_pass1_removed = removed_count
        else:
            self.phase1_stats.exact_hall_pass2_removed = removed_count
            
        logger.info(f"  Pass {pass_number}: Removed {removed_count}, Modified {modified_count} subtitles")
        return filtered

    def _phase1_extreme_repetition_cleaning(self, subtitles: List[pysrt.SubRipItem]) -> List[pysrt.SubRipItem]:
        """Apply only extreme/obvious repetition cleaning"""
        if not self.repetition_cleaner:
            logger.info("  Extreme repetition cleaning skipped (disabled)")
            return subtitles
            
        processed = []
        cleaned_count = 0
        
        for i, sub in enumerate(subtitles):
            # Apply only the most obvious repetition patterns
            cleaned_text, mods = self._apply_extreme_repetition_only(sub.text)
            
            if not cleaned_text or not cleaned_text.strip():
                # Text became empty after cleaning
                self._record_removal(sub, i, "extreme_repetition_empty", "repetition")
            elif cleaned_text != sub.text:
                # Text was modified
                modified_sub = pysrt.SubRipItem(
                    index=sub.index,
                    start=sub.start,
                    end=sub.end,
                    text=cleaned_text
                )
                self._record_modification(sub, modified_sub, i, mods, "extreme_repetition_cleaning")
                processed.append(modified_sub)
                cleaned_count += 1
            else:
                # Text unchanged
                processed.append(sub)
                
        self.phase1_stats.repetition_cleaned = cleaned_count
        logger.info(f"  Cleaned {cleaned_count} subtitles with extreme repetitions")
        return processed

    def _apply_extreme_repetition_only(self, text: str) -> Tuple[str, List[Dict]]:
        """Apply improved repetition patterns from Recommendation 1"""
        if not text or not text.strip():
            return text, []
            
        modifications = []
        current_text = text
        
        # IMPROVED PATTERNS FROM RECOMMENDATION 1
        import re
        
        # 1. Character repetitions (Japanese chars, 3+ repetitions) - MUCH LOWER THRESHOLD
        char_repeat_pattern = re.compile(r'(([ぁ-ゖァ-ヺ])\2{2,})')
        matches = list(char_repeat_pattern.finditer(current_text))
        for match in reversed(matches):
            full_match = match.group(1)
            char = match.group(2)
            replacement = char * 2  # Reduce to 2 characters
            current_text = current_text[:match.start(1)] + replacement + current_text[match.end(1):]
            
            modifications.append({
                'type': 'improved_character_repetition',
                'pattern': 'japanese_char_repeat_3plus',
                'original': full_match,
                'modified': replacement,
                'confidence': 0.95
            })
            
        # 2. Comma-separated character repetitions (6+ repetitions)
        comma_repeat_pattern = re.compile(r'(([ぁ-ゖァ-ヺ]、){6,})')
        matches = list(comma_repeat_pattern.finditer(current_text))
        for match in reversed(matches):
            full_match = match.group(0)
            char_comma = match.group(2)
            replacement = char_comma * 3  # Reduce to 3 repetitions
            current_text = current_text[:match.start()] + replacement + current_text[match.end():]
            
            modifications.append({
                'type': 'improved_comma_repetition',
                'pattern': 'japanese_comma_repeat_6plus',
                'original': full_match,
                'modified': replacement,
                'confidence': 0.95
            })
            
        # 3. Word repetitions (any word 1-5 chars, 3+ repetitions)
        word_repeat_pattern = re.compile(r'((\w{1,5})(?:\2){2,})')
        matches = list(word_repeat_pattern.finditer(current_text))
        for match in reversed(matches):
            full_match = match.group(1)
            word = match.group(2)
            replacement = word * 2  # Reduce to 2 repetitions
            current_text = current_text[:match.start(1)] + replacement + current_text[match.end(1):]
            
            modifications.append({
                'type': 'improved_word_repetition',
                'pattern': 'word_repeat_3plus',
                'original': full_match,
                'modified': replacement,
                'confidence': 0.9
            })
            
        # 4. Extreme vocalization patterns (10+ characters) - Keep for very extreme cases
        repeated_vocalization_pattern = re.compile(r'([あアぁァ]{10,}|[いイぃィ]{10,}|[うウぅゥ]{10,}|[えエぇェ]{10,}|[おオぉォ]{10,})')
        matches = list(repeated_vocalization_pattern.finditer(current_text))
        for match in reversed(matches):
            full_match = match.group(0)
            first_char = full_match[0]
            replacement = first_char * 2  # Reduce to 2 characters
            current_text = current_text[:match.start()] + replacement + current_text[match.end():]
            
            modifications.append({
                'type': 'extreme_vocalization',
                'pattern': 'vocalization_10plus',
                'original': full_match,
                'modified': replacement,
                'confidence': 0.98
            })
            
        # 5. Numeric repetitions (for completeness)
        numeric_pattern = re.compile(r'(\d{2,})(?:\1{1,})')
        matches = list(numeric_pattern.finditer(current_text))
        for match in reversed(matches):
            full_match = match.group(0)
            number = match.group(1)
            replacement = number  # Keep only one instance
            current_text = current_text[:match.start()] + replacement + current_text[match.end():]
            
            modifications.append({
                'type': 'numeric_repetition',
                'pattern': 'numeric_repeat',
                'original': full_match,
                'modified': replacement,
                'confidence': 0.9
            })
            
        return current_text, modifications

    def _phase1_purge_empty(self, subtitles: List[pysrt.SubRipItem]) -> List[pysrt.SubRipItem]:
        """Remove any subtitles that became empty during Phase 1"""
        filtered = []
        purged_count = 0
        
        for i, sub in enumerate(subtitles):
            if not sub.text or not sub.text.strip():
                self._record_removal(sub, i, "purged_empty_phase1", "cleanup")
                purged_count += 1
            else:
                filtered.append(sub)
                
        self.phase1_stats.empty_purged = purged_count
        logger.info(f"  Purged {purged_count} empty subtitles created during Phase 1")
        return filtered

    def _phase1_renumber(self, subtitles: List[pysrt.SubRipItem]) -> List[pysrt.SubRipItem]:
        """Renumber subtitles sequentially"""
        for i, sub in enumerate(subtitles, 1):
            sub.index = i
        logger.info(f"  Renumbered {len(subtitles)} subtitles")
        return subtitles

    def _log_phase1_results(self):
        """Log comprehensive Phase 1 results"""
        stats = self.phase1_stats
        
        logger.info("=== PHASE 1 RESULTS SUMMARY ===")
        logger.info(f"Original subtitles: {stats.original_count}")
        logger.info(f"Exact hallucination pass 1 removed: {stats.exact_hall_pass1_removed}")
        logger.info(f"Extreme repetition cleaned: {stats.repetition_cleaned}")
        logger.info(f"Exact hallucination pass 2 removed: {stats.exact_hall_pass2_removed}")
        logger.info(f"Empty subtitles purged: {stats.empty_purged}")
        logger.info(f"Final subtitles: {stats.final_count}")
        
        total_removed = (stats.exact_hall_pass1_removed + stats.exact_hall_pass2_removed + stats.empty_purged)
        reduction_percent = (total_removed / stats.original_count * 100) if stats.original_count > 0 else 0
        
        logger.info(f"Total removed: {total_removed} ({reduction_percent:.1f}%)")
        
        if stats.hallucination_phrases_loaded:
            logger.info("Hallucination database usage:")
            for lang, count in stats.hallucination_phrases_loaded.items():
                logger.info(f"  - {lang}: {count} phrases available")
                
        logger.info("===============================")

    # [Include all the existing helper methods from the original code: 
    #  _setup_output_paths, _record_removal, _record_modification, etc.]
    # ... (keeping this shorter for readability, but all existing methods remain)

    def _record_removal(self, subtitle: pysrt.SubRipItem, original_index: int, reason: str, category: str):
        """Record a completely removed subtitle"""
        entry = ArtifactEntry(
            index=original_index + 1,
            start_time=str(subtitle.start),
            end_time=str(subtitle.end),
            original_text=subtitle.text,
            modified_text=None,
            reason=reason,
            category=category,
            confidence=1.0,
            pattern=None,
            step="phase1_conservative",
            additional_info={}
        )
        self.artifact_entries.append(entry)
        
    def _record_modification(self, original: pysrt.SubRipItem, modified: pysrt.SubRipItem, 
                           original_index: int, modifications: List[Dict], step_name: str = "phase1_conservative"):
        """Record a modified subtitle"""
        if self.config.artifact_detail_level == "minimal":
            return
            
        # Combine modification info
        categories = set()
        patterns = []
        min_confidence = 1.0
        
        for mod in modifications:
            categories.add(mod.get('category', mod.get('type', 'unknown')))
            if 'pattern' in mod:
                patterns.append(mod['pattern'])
            if 'confidence' in mod:
                min_confidence = min(min_confidence, mod['confidence'])
                
        entry = ArtifactEntry(
            index=original_index + 1,
            start_time=str(original.start),
            end_time=str(original.end),
            original_text=original.text,
            modified_text=modified.text,
            reason="multiple_modifications" if len(modifications) > 1 else modifications[0].get('type', 'unknown'),
            category=','.join(categories),
            confidence=min_confidence,
            pattern=patterns[0] if len(patterns) == 1 else None,
            step=step_name,
            additional_info={'modifications': modifications} if self.config.artifact_detail_level == "full" else {}
        )
        self.artifact_entries.append(entry)

    def _setup_output_paths(self, input_path: Path) -> Dict[str, Path]:
        """Setup all output file paths"""
        paths = {}
        
        # Always create raw_subs folder in the input file's parent directory
        raw_subs_dir = input_path.parent / self.constants['processing'].RAW_SUBS_FOLDER
        raw_subs_dir.mkdir(exist_ok=True)
        
        # Original path
        paths['original'] = input_path
        
        # Backup path
        if self.config.save_original:
            backup_name = f"{input_path.stem}.{self.constants['processing'].ORIGINAL_BACKUP_SUFFIX}{input_path.suffix}"
            paths['original_backup'] = raw_subs_dir / backup_name
            
        # Sanitized path
        if self.config.preserve_original_file:
            sanitized_name = f"{input_path.stem}.{self.constants['processing'].SANITIZED_SUFFIX}{input_path.suffix}"
            paths['sanitized'] = input_path.parent / sanitized_name
        else:
            # When not preserving original, save sanitized to raw_subs
            sanitized_name = f"{input_path.stem}.{self.constants['processing'].SANITIZED_SUFFIX}{input_path.suffix}"
            paths['sanitized'] = raw_subs_dir / sanitized_name
            
        # Artifacts path
        if self.config.save_artifacts:
            artifacts_name = f"{input_path.stem}.{self.constants['processing'].ARTIFACTS_SUFFIX}{input_path.suffix}"
            paths['artifacts'] = raw_subs_dir / artifacts_name
            
        return paths
        
    def _save_srt(self, subtitles: List[pysrt.SubRipItem], output_path: Path):
        """Save subtitles to SRT file"""
        output_path.parent.mkdir(parents=True, exist_ok=True)
        srt_file = pysrt.SubRipFile(subtitles)
        srt_file.save(str(output_path), encoding='utf-8')
        logger.info(f"Saved sanitized SRT to: {output_path}")
        
    def _save_artifacts_srt(self, artifacts_path: Path):
        """Save artifacts as SRT file with detailed information"""
        artifacts_subs = []
        
        # Add summary as first subtitle
        if self.config.artifact_detail_level in ["full", "summary"]:
            summary = self._create_summary_subtitle()
            artifacts_subs.append(summary)
            
        # Group artifacts by type
        removals = [e for e in self.artifact_entries if e.modified_text is None]
        modifications = [e for e in self.artifact_entries if e.modified_text is not None]
        
        # Add removal entries
        for entry in removals:
            sub = self._create_artifact_subtitle(entry, len(artifacts_subs) + 1)
            artifacts_subs.append(sub)
            
        # Add modification entries
        for entry in modifications:
            sub = self._create_artifact_subtitle(entry, len(artifacts_subs) + 1)
            artifacts_subs.append(sub)
            
        # Save artifacts file
        if artifacts_subs:
            artifacts_path.parent.mkdir(parents=True, exist_ok=True)
            artifacts_file = pysrt.SubRipFile(artifacts_subs)
            artifacts_file.save(str(artifacts_path), encoding='utf-8')
            logger.info(f"Saved artifacts to: {artifacts_path}")

    def _create_summary_subtitle(self) -> pysrt.SubRipItem:
        """Create summary subtitle for artifacts file"""
        stats = self.phase1_stats
        
        summary_text = f"""[PHASE 1 SANITIZATION SUMMARY]
Original subtitles: {stats.original_count}
Exact hallucination pass 1 removed: {stats.exact_hall_pass1_removed}
Extreme repetition cleaned: {stats.repetition_cleaned}
Exact hallucination pass 2 removed: {stats.exact_hall_pass2_removed}
Empty subtitles purged: {stats.empty_purged}
Final subtitles: {stats.final_count}
Configuration: {self.config.sensitivity_mode} mode"""
        
        if stats.hallucination_phrases_loaded:
            summary_text += "\nHallucination database:"
            for lang, count in stats.hallucination_phrases_loaded.items():
                summary_text += f"\n  {lang}: {count} phrases"
        
        return pysrt.SubRipItem(
            index=1,
            start=pysrt.SubRipTime(milliseconds=0),
            end=pysrt.SubRipTime(milliseconds=5000),
            text=summary_text
        )

    def _create_artifact_subtitle(self, entry: ArtifactEntry, index: int) -> pysrt.SubRipItem:
        """Create subtitle entry for artifact"""
        if entry.modified_text is None:
            # Removal entry
            text = f"""[REMOVED - {entry.reason}]
Original: {entry.original_text}
Category: {entry.category}
Step: {entry.step}
Confidence: {entry.confidence:.2f}"""
        else:
            # Modification entry
            text = f"""[MODIFIED - {entry.reason}]
Original: {entry.original_text}
Modified: {entry.modified_text}
Category: {entry.category}
Step: {entry.step}"""
            
        # Add pattern info if available and in full mode
        if self.config.artifact_detail_level == "full" and entry.pattern:
            text += f"\nPattern: {entry.pattern[:50]}..."
            
        # Handle timing
        try:
            if entry.start_time == "multiple":
                start = pysrt.SubRipTime(milliseconds=index * 5000)
                end = pysrt.SubRipTime(milliseconds=index * 5000 + 5000)
            else:
                start = self._parse_time_string(entry.start_time)
                end = self._parse_time_string(entry.end_time)
        except:
            start = pysrt.SubRipTime(milliseconds=index * 5000)
            end = pysrt.SubRipTime(milliseconds=index * 5000 + 5000)
            
        return pysrt.SubRipItem(
            index=index,
            start=start,
            end=end,
            text=text
        )

    def _parse_time_string(self, time_str: str) -> pysrt.SubRipTime:
        """Parse time string to SubRipTime"""
        parts = time_str.replace(',', '.').split(':')
        hours = int(parts[0])
        minutes = int(parts[1])
        seconds_parts = parts[2].split('.')
        seconds = int(seconds_parts[0])
        milliseconds = int(seconds_parts[1]) if len(seconds_parts) > 1 else 0
        
        return pysrt.SubRipTime(hours=hours, minutes=minutes, seconds=seconds, milliseconds=milliseconds)
        
    def _calculate_statistics(self, original_count: int, final_count: int) -> Dict[str, Any]:
        """Calculate processing statistics"""
        stats = {
            'original_subtitle_count': original_count,
            'final_subtitle_count': final_count,
            'total_modifications': len(self.artifact_entries),
            'removals': sum(1 for e in self.artifact_entries if e.modified_text is None),
            'modifications': sum(1 for e in self.artifact_entries if e.modified_text is not None),
            'reduction_percentage': ((original_count - final_count) / original_count * 100) if original_count > 0 else 0
        }
        
        # Add Phase 1 specific stats
        stats['phase1_stats'] = {
            'exact_hallucination_pass1_removed': self.phase1_stats.exact_hall_pass1_removed,
            'extreme_repetition_cleaned': self.phase1_stats.repetition_cleaned,
            'exact_hallucination_pass2_removed': self.phase1_stats.exact_hall_pass2_removed,
            'empty_purged': self.phase1_stats.empty_purged,
            'hallucination_database_size': self.phase1_stats.hallucination_phrases_loaded
        }
        
        # Count by category
        category_counts = {}
        for entry in self.artifact_entries:
            for cat in entry.category.split(','):
                category_counts[cat] = category_counts.get(cat, 0) + 1
                
        stats['modifications_by_category'] = category_counts
        
        # Count by step
        step_counts = {}
        for entry in self.artifact_entries:
            step_counts[entry.step] = step_counts.get(entry.step, 0) + 1
            
        stats['modifications_by_step'] = step_counts
        
        return stats